<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FloodBoy Blockchain Viewer</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }

        .card-shadow {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: 0.5rem;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3B82F6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        [v-cloak] {
            display: none;
        }
    </style>
</head>

<body class="p-4 md:p-8">

    <div id="app" class="max-w-6xl mx-auto space-y-6">
        <!-- Header -->
        <header class="bg-white rounded-xl p-6 card-shadow relative">
            <div id="loading-header" class="loading-overlay hidden">
                <div class="spinner"></div>
            </div>

            <div class="flex flex-col md:flex-row justify-between items-start md:items-center">
                <div>
                    <h1 class="text-3xl font-bold text-gray-800">Latest Sensor Data</h1>
                    <h2 id="store-nickname" class="text-2xl font-semibold text-blue-600 mt-2">Loading...</h2>
                    <p id="store-desc" class="text-gray-500 mt-1">Connecting to blockchain...</p>
                </div>

                <div class="mt-4 md:mt-0 text-right space-y-1">
                    <div class="flex items-center justify-end space-x-2">
                        <div class="w-2 h-2 rounded-full bg-green-500"></div>
                        <span id="current-block" class="text-sm font-medium text-gray-700">Current Block: ...</span>
                    </div>
                    <div id="last-updated" class="text-sm text-gray-500">Last Updated: ...</div>
                    <div class="text-sm text-gray-500">
                        <span id="store-address">0x...</span>
                        <a id="store-link" href="#" target="_blank" class="text-blue-500 hover:text-blue-700"><i
                                class="fas fa-external-link-alt ml-1"></i></a>
                    </div>
                </div>
            </div>

            <!-- Store Selector for Demo -->
            <div class="mt-4 border-t pt-4 flex space-x-4">
                <span class="text-sm font-medium text-gray-600 self-center">Select Store:</span>
                <button onclick="switchStore('0xCd3Ec17ddFDa24f8F97131fa0FDf20e7cbd1A8Bb')"
                    class="px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded text-sm text-gray-800 transition">FloodBoy001</button>
                <button onclick="switchStore('0x0994Bc66b2863f8D58C8185b1ed6147895632812')"
                    class="px-3 py-1 bg-gray-100 hover:bg-gray-200 rounded text-sm text-gray-800 transition">FloodBoy016</button>
            </div>
        </header>

        <!-- Chart Section -->
        <section class="bg-white rounded-xl p-6 card-shadow relative">
            <div id="loading-chart" class="loading-overlay hidden">
                <div class="spinner"></div>
            </div>

            <div class="flex flex-col md:flex-row justify-between items-center mb-4 border-b pb-4">
                <h3 id="chart-title" class="text-xl font-bold text-gray-800">Water Depth Over Time</h3>
                <div class="flex space-x-2 mt-4 md:mt-0 bg-gray-100 p-1 rounded-lg">
                    <button id="toggle-water" onclick="toggleChart('waterDepth')"
                        class="px-4 py-2 bg-blue-500 text-white rounded-md text-sm font-medium transition shadow-sm">Water
                        Depth</button>
                    <button id="toggle-battery" onclick="toggleChart('batteryVoltage')"
                        class="px-4 py-2 text-gray-600 hover:text-gray-900 rounded-md text-sm font-medium transition">Battery
                        Voltage</button>
                </div>
            </div>

            <div class="w-full h-[400px]">
                <canvas id="sensorChart"></canvas>
                <div id="no-data-msg" class="hidden h-full flex items-center justify-center text-gray-500 italic">No
                    historical data available</div>
            </div>
        </section>

        <!-- Data Table Section -->
        <section class="bg-white rounded-xl p-6 card-shadow relative overflow-hidden">
            <div id="loading-table" class="loading-overlay hidden">
                <div class="spinner"></div>
            </div>

            <h3 class="text-xl font-bold text-gray-800 mb-4">Latest Readings</h3>
            <div class="overflow-x-auto">
                <table class="w-full text-left border-collapse">
                    <thead>
                        <tr class="bg-gray-50 border-b border-gray-200">
                            <th class="p-3 font-semibold text-gray-600">Metric</th>
                            <th class="p-3 font-semibold text-gray-600">Current</th>
                            <th class="p-3 font-semibold text-gray-600">Min</th>
                            <th class="p-3 font-semibold text-gray-600">Max</th>
                        </tr>
                    </thead>
                    <tbody id="data-table-body">
                        <!-- Data rows injected by JS -->
                        <tr>
                            <td colspan="4" class="p-4 text-center text-gray-500">Loading data...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Footer -->
        <footer class="bg-white rounded-xl p-6 card-shadow text-sm text-gray-500 space-y-2">
            <div class="flex justify-between items-center flex-wrap gap-2">
                <div id="footer-updated">Last Updated: ...</div>
                <div>
                    Store Owner: <span id="store-owner" class="font-mono">0x...</span>
                    <a id="owner-link" href="#" target="_blank" class="text-blue-500 hover:text-blue-700 ml-1"><i
                            class="fas fa-external-link-alt"></i></a>
                </div>
            </div>
            <div class="flex justify-between items-center flex-wrap gap-2">
                <div>Deployed Block: <a id="deployed-block" href="#" target="_blank"
                        class="text-blue-500 hover:underline">#...</a></div>
                <div id="sensor-count">Sensor Count: ...</div>
            </div>
        </footer>
    </div>

    <!-- Application Logic -->
    <script type="module">
        import { createPublicClient, http, getContract } from 'https://esm.sh/viem@2.9.11';

        // ABIs based on provided spec
        const FactoryABI = [
            {
                "name": "getStoreInfo", "inputs": [{ "name": "store", "type": "address" }], "outputs": [
                    { "name": "nickname", "type": "string" },
                    { "name": "owner", "type": "address" },
                    { "name": "authorizedSensorCount", "type": "uint256" },
                    { "name": "deployedBlock", "type": "uint128" },
                    { "name": "description", "type": "string" }
                ], "stateMutability": "view", "type": "function"
            }
        ];

        const StoreABI = [
            {
                "name": "getAllFields", "outputs": [{
                    "components": [
                        { "name": "name", "type": "string" },
                        { "name": "unit", "type": "string" },
                        { "name": "dtype", "type": "string" }
                    ], "type": "tuple[]"
                }], "stateMutability": "view", "type": "function"
            },
            {
                "name": "getLatestRecord", "inputs": [{ "name": "sensor", "type": "address" }], "outputs": [
                    { "name": "", "type": "uint256" },
                    { "name": "", "type": "int256[]" }
                ], "stateMutability": "view", "type": "function"
            },
            {
                "anonymous": false, "inputs": [
                    { "indexed": true, "name": "sensor", "type": "address" },
                    { "indexed": false, "name": "timestamp", "type": "uint256" },
                    { "indexed": false, "name": "values", "type": "int256[]" }
                ], "name": "RecordStored", "type": "event"
            } // Added event signature for historical data
        ];

        // JIBCHAIN Setup
        const jibchain = {
            id: 8899,
            name: 'JIBCHAIN L1',
            rpcUrls: { default: { http: ['https://rpc-l1.jibchain.net'] } }
        };

        const client = createPublicClient({ chain: jibchain, transport: http() });

        // Constants
        const FACTORY_ADDRESS = '0x63bB41b79b5aAc6e98C7b35Dcb0fE941b85Ba5Bb';
        const UNIVERSAL_SIGNER = '0xcB0e58b011924e049ce4b4D62298Edf43dFF0BDd';

        // App State
        let currentStore = '0x0994Bc66b2863f8D58C8185b1ed6147895632812'; // Default: FloodBoy016
        let chartInstance = null;
        let globalHistoricalData = [];
        let currentFields = [];
        let activeChartType = 'waterDepth'; // 'waterDepth' or 'batteryVoltage'

        // UI Helpers
        const toggleLoader = (id, show) => {
            const el = document.getElementById(id);
            if (el) {
                if (show) el.classList.remove('hidden'); else el.classList.add('hidden');
            }
        };

        const truncateAddress = (addr) => `${addr.substring(0, 6)}...${addr.substring(addr.length - 6)}`;

        const formatTimestamp = (ts) => {
            const d = new Date(Number(ts));
            return d.toLocaleString('en-US', { year: 'numeric', month: '2-digit', day: '2-digit', hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true });
        };

        // Formatting based strictly on prompt requirements
        function formatFieldName(fieldName) {
            return fieldName.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');
        }

        function processValue(value, unit) {
            if (value === null || value === undefined) return '-';

            const baseUnit = unit.replace(/ x\\d+/, '');

            if (unit.includes('x10000')) {
                return (Number(value) / 10000).toFixed(4) + ' ' + baseUnit;
            }
            if (unit.includes('x1000')) {
                return (Number(value) / 1000).toFixed(3) + ' ' + baseUnit;
            }
            if (unit.includes('x100')) {
                return (Number(value) / 100).toFixed(3) + ' ' + baseUnit;
            }

            return value + ' ' + baseUnit;
        }

        // Chart Management
        function renderChart() {
            const ctx = document.getElementById('sensorChart').getContext('2d');
            const noDataMsg = document.getElementById('no-data-msg');

            if (chartInstance) chartInstance.destroy();

            if (globalHistoricalData.length === 0) {
                document.getElementById('sensorChart').style.display = 'none';
                noDataMsg.classList.remove('hidden');
                return;
            }

            document.getElementById('sensorChart').style.display = 'block';
            noDataMsg.classList.add('hidden');

            const isWater = activeChartType === 'waterDepth';
            const color = isWater ? '#3B82F6' : '#10B981'; // Blue vs Green
            const bgGradient = ctx.createLinearGradient(0, 0, 0, 400);
            bgGradient.addColorStop(0, isWater ? 'rgba(59, 130, 246, 0.2)' : 'rgba(16, 185, 129, 0.2)');
            bgGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            const dataPoints = globalHistoricalData.map(d => ({
                x: new Date(d.timestamp),
                y: isWater ? d.waterDepth : d.batteryVoltage
            })).filter(d => d.y !== null); // Filter out nulls if field doesn't exist

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: isWater ? 'Water Depth (m)' : 'Battery Voltage (V)',
                        data: dataPoints,
                        borderColor: color,
                        backgroundColor: bgGradient,
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHitRadius: 10,
                        pointHoverRadius: 5,
                        fill: true,
                        tension: 0.4 // Smoothing curve
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += isWater ? context.parsed.y.toFixed(4) : context.parsed.y.toFixed(3);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                displayFormats: { hour: 'MMM D, h a' }
                            },
                            grid: { display: false }
                        },
                        y: {
                            beginAtZero: false,
                            grid: { color: '#f3f4f6' }
                        }
                    }
                }
            });
        }

        window.toggleChart = function (type) {
            activeChartType = type;

            const btnW = document.getElementById('toggle-water');
            const btnB = document.getElementById('toggle-battery');
            const title = document.getElementById('chart-title');

            if (type === 'waterDepth') {
                btnW.className = "px-4 py-2 bg-blue-500 text-white rounded-md text-sm font-medium shadow-sm transition";
                btnB.className = "px-4 py-2 text-gray-600 hover:text-gray-900 rounded-md text-sm font-medium transition";
                title.innerText = "Water Depth Over Time";
            } else {
                btnB.className = "px-4 py-2 bg-green-500 text-white rounded-md text-sm font-medium shadow-sm transition";
                btnW.className = "px-4 py-2 text-gray-600 hover:text-gray-900 rounded-md text-sm font-medium transition";
                title.innerText = "Battery Voltage Over Time";
            }

            renderChart();
        };

        // Calculate aggregated min/max from historical data
        function calculateAggregates(valuesIndex) {
            let min = null, max = null;
            let validValues = globalHistoricalData.map(ev => {
                // events.args.values is int256[]
                return ev.rawValues ? Number(ev.rawValues[valuesIndex]) : null;
            }).filter(v => v !== null && !isNaN(v));

            if (validValues.length > 0) {
                min = Math.min(...validValues);
                max = Math.max(...validValues);
            }
            return { min, max, count: validValues.length };
        }

        async function loadData() {
            ['loading-header', 'loading-chart', 'loading-table'].forEach(id => toggleLoader(id, true));

            try {
                // 1. Get Block Number
                const blockNumber = await client.getBlockNumber();
                document.getElementById('current-block').innerText = \`Current Block: \${blockNumber}\`;

            // 2. Get Store Info from Factory
            const factoryResult = await client.readContract({
                address: FACTORY_ADDRESS, abi: FactoryABI, functionName: 'getStoreInfo', args: [currentStore]
            });
            
            const nickname = factoryResult[0];
            const owner = factoryResult[1];
            const sensorCount = factoryResult[2];
            const deployedBlock = factoryResult[3];
            const description = factoryResult[4];

            // Update UI Header
            document.getElementById('store-nickname').innerText = nickname;
            document.getElementById('store-desc').innerText = description;
            document.getElementById('store-address').innerText = truncateAddress(currentStore);
            document.getElementById('store-link').href = \`https://exp.jibchain.net/address/\${currentStore}\`;
            
            toggleLoader('loading-header', false);

            // Update UI Footer
            document.getElementById('store-owner').innerText = truncateAddress(owner);
            document.getElementById('owner-link').href = \`https://exp.jibchain.net/address/\${owner}\`;
            document.getElementById('deployed-block').innerText = \`#\${deployedBlock}\`;
            document.getElementById('deployed-block').href = \`https://exp.jibchain.net/block/\${deployedBlock}\`;
            document.getElementById('sensor-count').innerText = \`Sensor Count: \${sensorCount} authorized sensor\${sensorCount > 1 ? 's' : ''}\`;

            // 3. Get Subfield Definitions
            currentFields = await client.readContract({
                address: currentStore, abi: StoreABI, functionName: 'getAllFields'
            });

            // 4. Fetch Historical logs (Max past 24 hrs for demo, 28800 blocks)
            const fromBlock = blockNumber > 28800n ? blockNumber - 28800n : 0n;
            
            const historicalEvents = await client.getContractEvents({
                address: currentStore, abi: StoreABI, eventName: 'RecordStored',
                fromBlock, toBlock: 'latest', args: { sensor: UNIVERSAL_SIGNER }
            });

            // Find Indexes
            const wDepthIdx = currentFields.findIndex(f => f.name.toLowerCase().includes('water_depth') && !f.name.includes('min') && !f.name.includes('max'));
            const bVoltIdx = currentFields.findIndex(f => f.name.toLowerCase().includes('battery_voltage') && !f.name.includes('min') && !f.name.includes('max'));

            globalHistoricalData = historicalEvents.map(event => ({
                timestamp: Number(event.args.timestamp) * 1000,
                waterDepth: wDepthIdx >= 0 ? Number(event.args.values[wDepthIdx]) / 10000 : null,
                batteryVoltage: bVoltIdx >= 0 ? Number(event.args.values[bVoltIdx]) / 100 : null,
                rawValues: event.args.values // Store raw for min/max agg
            })).sort((a, b) => a.timestamp - b.timestamp);

            renderChart();
            toggleLoader('loading-chart', false);

            // 5. Get Latest Sensor Data to populate the table base
            const latestRes = await client.readContract({
                address: currentStore, abi: StoreABI, functionName: 'getLatestRecord', args: [UNIVERSAL_SIGNER]
            });

            const currentTimestamp = formatTimestamp(Number(latestRes[0]) * 1000);
            document.getElementById('last-updated').innerText = \`Last Updated: \${currentTimestamp}\`;
            document.getElementById('footer-updated').innerText = \`Last Updated: \${currentTimestamp}\`;

            const currentValues = latestRes[1];
            
            // Build Table
            const tbody = document.getElementById('data-table-body');
            tbody.innerHTML = '';

            currentFields.forEach((field, index) => {
                // Ignore min/max fields as we calculate them or if they exist just ignore them logically to build clean UI
                // Standardizing output.
                if(field.name.toLowerCase().includes('min') || field.name.toLowerCase().includes('max')) return;
                
                // Exclude meta fields that aren't measurement data
                if(field.name.toLowerCase().includes('count')) return;

                const rawVal = currentValues[index];
                
                // Get Aggregates from local historical sweep (acting as data grouping window)
                const aggs = calculateAggregates(index);
                const displayMin = aggs.min !== null ? processValue(aggs.min, field.unit) : '-';
                const displayMax = aggs.max !== null ? processValue(aggs.max, field.unit) : '-';
                const currentFormatted = processValue(rawVal, field.unit);
                
                // Format Field Name 
                let displayName = formatFieldName(field.name);
                
                // Add sample count if it's water depth
                if (field.name.toLowerCase().includes('water_depth') && aggs.count > 0) {
                    displayName = \`\${displayName} (\${aggs.count} samples)\`;
                }

                const row = document.createElement('tr');
                row.className = index % 2 === 0 ? 'bg-white' : 'bg-gray-50';
                row.innerHTML = \`
                    <td class="p-3 border-b border-gray-100 font-medium text-gray-800">\${displayName}</td>
                    <td class="p-3 border-b border-gray-100 text-gray-700">\${currentFormatted}</td>
                    <td class="p-3 border-b border-gray-100 text-gray-500">\${displayMin}</td>
                    <td class="p-3 border-b border-gray-100 text-gray-500">\${displayMax}</td>
                \`;
                tbody.appendChild(row);
            });

            toggleLoader('loading-table', false);

        } catch (error) {
            console.error(error);
            const body = document.getElementById('data-table-body');
            body.innerHTML = \`<tr><td colspan="4" class="p-4 text-center text-red-500">Error loading data: \${error.message}</td></tr>\`;
            ['loading-header', 'loading-chart', 'loading-table'].forEach(id => toggleLoader(id, false));
        }
    }

    // Expose to window for UI usage
    window.switchStore = (address) => {
        currentStore = address;
        loadData();
    };

    // Load setup
    // Chart.js requires time adapter for time axis
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js';
    script.onload = () => {
        loadData();
    };
    document.head.appendChild(script);

    </script>
</body>

</html>