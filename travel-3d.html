<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚òÄÔ∏è Antigravity Train (Morning) ‚Äî Chiang Mai ‚Üí Phitsanulok</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    body {
      background: #a0c4ff;
      overflow: hidden;
      font-family: -apple-system, 'Noto Sans Thai', sans-serif;
    }

    canvas {
      display: block;
    }

    #hud {
      position: absolute;
      top: 16px;
      left: 16px;
      color: #e6edf3;
      z-index: 10;
      background: rgba(5, 5, 16, 0.85);
      border: 1px solid rgba(88, 166, 255, 0.3);
      border-radius: 12px;
      padding: 16px 20px;
      backdrop-filter: blur(16px);
      min-width: 240px;
    }

    #hud h2 {
      color: #58a6ff;
      font-size: 18px;
      margin-bottom: 8px;
    }

    #hud .loc {
      color: #f778ba;
      font-size: 15px;
      font-weight: 600;
      min-height: 22px;
    }

    #hud .time {
      color: #3fb950;
      font-size: 13px;
      font-family: monospace;
      margin-top: 2px;
    }

    #hud .stat {
      color: #8b949e;
      font-size: 12px;
      margin-top: 8px;
      line-height: 1.5;
    }

    #hud .stat span {
      color: #58a6ff;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
    }

    #controls button {
      background: rgba(88, 166, 255, 0.15);
      color: #58a6ff;
      border: 1px solid rgba(88, 166, 255, 0.4);
      border-radius: 10px;
      padding: 10px 22px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      backdrop-filter: blur(8px);
      transition: all 0.2s;
    }

    #controls button:hover {
      background: rgba(88, 166, 255, 0.3);
    }

    #controls button.active {
      background: #58a6ff;
      color: #050510;
    }

    #speed {
      position: absolute;
      bottom: 20px;
      right: 20px;
      color: #8b949e;
      font-size: 12px;
      z-index: 10;
    }

    #progress {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: rgba(88, 166, 255, 0.1);
      z-index: 10;
    }

    #progressBar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #3fb950, #58a6ff, #f778ba);
      transition: width 0.1s;
    }

    .oracle-footer {
      position: absolute;
      bottom: 8px;
      right: 20px;
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.4);
      z-index: 10;
      pointer-events: auto;
      text-align: right;
    }
  </style>
</head>

<body>

  <div id="hud">
    <h2>‚òÄÔ∏è ‡∏Ç‡∏ö‡∏ß‡∏ô 8 ‚Äî Antigravity (Morning)</h2>
    <div class="loc" id="locName">‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏£‡∏ñ‡πÑ‡∏ü‡πÄ‡∏ä‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà</div>
    <div class="time" id="locTime">Feb 27, 06:00</div>
    <div class="stat">
      Route: <span>Chiang Mai ‚Üí Phitsanulok</span><br>
      Distance: <span>~300 km</span> ¬∑ Waypoints: <span>34</span><br>
      <span style="color:#f778ba;">Antigravity ‚Äî The Unseen Force</span>
    </div>
  </div>

  <div id="controls">
    <button onclick="togglePlay()" id="playBtn" class="active">‚è∏ Pause</button>
    <button onclick="toggleCamera()" id="camBtn" class="active">üé• On Train</button>
    <button onclick="resetView()">‚Ü∫ Reset</button>
  </div>

  <div id="speed"></div>
  <div id="progress">
    <div id="progressBar"></div>
  </div>
  <div class="oracle-footer">
    <div>ü§ñ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏î‡∏¢ <strong>Antigravity Oracle</strong> ‚Äî The Unseen Force</div>
    <div style="margin-top: 5px; font-size: 0.85rem;">
      <a href="index.html" style="color: #58a6ff; text-decoration: none;">üè† Home</a> ‚Ä¢
      <a href="travel-map.html" style="color: #58a6ff; text-decoration: none;">üó∫Ô∏è 2D Map</a> ‚Ä¢
      <a href="dustboy-3d.html" style="color: #58a6ff; text-decoration: none;">‚ö° 3D ‡∏ù‡∏∏‡πà‡∏ô</a> ‚Ä¢
      <a href="cv.html" style="color: #58a6ff; text-decoration: none;">üë§ CV</a>
    </div>
  </div>

  <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
  }
}
</script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- DATA ---
    const waypoints = [
      { lat: 18.7513, lon: 98.9856, t: "Feb 27 06:00", p: "‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏£‡∏ñ‡πÑ‡∏ü‡πÄ‡∏ä‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà", type: "start" },
      { lat: 18.783165, lon: 99.028121, t: "06:16", p: "‡πÄ‡∏ä‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà ‚Äî ‡∏≠‡∏≠‡∏Å‡πÄ‡∏°‡∏∑‡∏≠‡∏á", type: "travel" },
      { lat: 18.715515, lon: 99.039492, t: "07:39", p: "‡∏™‡∏≤‡∏£‡∏†‡∏µ", type: "travel" },
      { lat: 18.636401, lon: 99.041813, t: "07:44", p: "‡∏•‡∏≥‡∏û‡∏π‡∏ô", type: "travel" },
      { lat: 18.595417, lon: 99.020958, t: "07:48", p: "‡∏•‡∏≥‡∏û‡∏π‡∏ô", type: "travel" },
      { lat: 18.500356, lon: 99.05973, t: "07:59", p: "‡∏•‡∏≥‡∏û‡∏π‡∏ô ‚Äî ‡πÉ‡∏ï‡πâ‡πÄ‡∏°‡∏∑‡∏≠‡∏á", type: "travel" },
      { lat: 18.456107, lon: 99.087873, t: "08:14", p: "‡πÅ‡∏°‡πà‡∏ó‡∏≤", type: "travel" },
      { lat: 18.461019, lon: 99.137354, t: "08:18", p: "‡πÅ‡∏°‡πà‡∏ó‡∏≤ ‚Äî ‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏≠‡∏≠‡∏Å", type: "travel" },
      { lat: 18.502889, lon: 99.202138, t: "08:24", p: "‡πÅ‡∏°‡πà‡∏ó‡∏≤ ‚Äî ‡πÄ‡∏Ç‡πâ‡∏≤‡∏†‡∏π‡πÄ‡∏Ç‡∏≤", type: "travel" },
      { lat: 18.508437, lon: 99.263119, t: "08:34", p: "‡πÅ‡∏°‡πà‡∏ó‡∏≤ ‚Äî ‡∏ó‡∏≤‡∏á‡∏´‡∏•‡∏ß‡∏á 3003", type: "travel" },
      { lat: 18.392756, lon: 99.265662, t: "09:01", p: "‡∏´‡πâ‡∏≤‡∏á‡∏â‡∏±‡∏ï‡∏£", type: "travel" },
      { lat: 18.348319, lon: 99.35155, t: "09:17", p: "‡∏´‡πâ‡∏≤‡∏á‡∏â‡∏±‡∏ï‡∏£ ‚Äî ‡∏†‡∏π‡πÄ‡∏Ç‡∏≤", type: "travel" },
      { lat: 18.312283, lon: 99.413179, t: "09:22", p: "‡∏•‡∏≥‡∏õ‡∏≤‡∏á", type: "travel" },
      { lat: 18.281088, lon: 99.469882, t: "09:27", p: "‡∏•‡∏≥‡∏õ‡∏≤‡∏á ‚Äî ‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ", type: "stop" },
      { lat: 18.223882, lon: 99.515192, t: "09:37", p: "‡∏•‡∏≥‡∏õ‡∏≤‡∏á ‚Äî ‡∏≠‡∏≠‡∏Å‡πÄ‡∏°‡∏∑‡∏≠‡∏á", type: "travel" },
      { lat: 18.202323, lon: 99.560287, t: "09:43", p: "‡πÅ‡∏°‡πà‡∏ó‡∏≤ ‚Äî ‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏Ç‡∏≤", type: "travel" },
      { lat: 18.240787, lon: 99.596923, t: "09:48", p: "‡πÄ‡∏Ç‡∏≤‡∏™‡∏π‡∏á", type: "travel" },
      { lat: 18.256232, lon: 99.655373, t: "09:53", p: "‡πÅ‡∏°‡πà‡πÄ‡∏°‡∏≤‡∏∞", type: "travel" },
      { lat: 18.264667, lon: 99.709782, t: "09:58", p: "‡πÅ‡∏°‡πà‡πÄ‡∏°‡∏≤‡∏∞", type: "travel" },
      { lat: 18.277847, lon: 99.801018, t: "10:06", p: "‡πÅ‡∏°‡πà‡πÄ‡∏°‡∏≤‡∏∞ ‚Äî ‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏≠‡∏≠‡∏Å", type: "travel" },
      { lat: 18.297822, lon: 99.86354, t: "10:14", p: "‡πÄ‡∏Ç‡πâ‡∏≤‡∏≠‡∏∏‡∏ï‡∏£‡∏î‡∏¥‡∏ï‡∏ñ‡πå", type: "travel" },
      { lat: 18.211666, lon: 99.871989, t: "10:29", p: "‡∏≠.‡∏•‡∏≠‡∏á ‚Äî ‡∏û‡∏±‡∏Å", type: "stop" },
      { lat: 18.096358, lon: 99.866883, t: "10:49", p: "‡∏≠.‡∏•‡∏≠‡∏á", type: "travel" },
      { lat: 18.040347, lon: 99.916938, t: "11:09", p: "‡∏≠.‡∏•‡∏≠‡∏á ‚Äî ‡πÉ‡∏ï‡πâ", type: "travel" },
      { lat: 17.97274, lon: 100.052057, t: "11:31", p: "‡πÄ‡∏î‡πà‡∏ô‡∏ä‡∏±‡∏¢", type: "travel" },
      { lat: 17.92115, lon: 100.062211, t: "11:36", p: "‡πÄ‡∏î‡πà‡∏ô‡∏ä‡∏±‡∏¢ ‚Äî ‡∏ó‡∏µ‡πà‡∏£‡∏≤‡∏ö", type: "travel" },
      { lat: 17.839016, lon: 100.046134, t: "11:47", p: "‡∏≠‡∏∏‡∏ï‡∏£‡∏î‡∏¥‡∏ï‡∏ñ‡πå", type: "travel" },
      { lat: 17.77201, lon: 100.108, t: "11:57", p: "‡∏≠‡∏∏‡∏ï‡∏£‡∏î‡∏¥‡∏ï‡∏ñ‡πå", type: "travel" },
      { lat: 17.723428, lon: 100.126752, t: "12:02", p: "‡∏≠‡∏∏‡∏ï‡∏£‡∏î‡∏¥‡∏ï‡∏ñ‡πå", type: "travel" },
      { lat: 17.652857, lon: 100.122463, t: "12:07", p: "‡∏≠‡∏∏‡∏ï‡∏£‡∏î‡∏¥‡∏ï‡∏ñ‡πå ‚Äî ‡∏≠‡∏≠‡∏Å‡πÄ‡∏°‡∏∑‡∏≠‡∏á", type: "travel" },
      { lat: 17.599924, lon: 100.093404, t: "12:23", p: "‡∏ö‡πâ‡∏≤‡∏ô‡πÇ‡∏Ñ‡∏Å ‚Äî ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢", type: "travel" },
      { lat: 16.817458, lon: 100.25806, t: "16:23", p: "‡∏°.‡∏£‡∏≤‡∏ä‡∏†‡∏±‡∏è‡∏û‡∏¥‡∏ö‡∏π‡∏•‡∏™‡∏á‡∏Ñ‡∏£‡∏≤‡∏° ‚Äî ‡∏ñ‡∏∂‡∏á‡πÅ‡∏•‡πâ‡∏ß!", type: "stop" },
      { lat: 16.83486, lon: 100.213662, t: "Feb 28 09:01", p: "PSRU ‚Äî ‡πÄ‡∏ß‡∏¥‡∏£‡πå‡∏Å‡∏ä‡∏≠‡∏õ‡πÄ‡∏£‡∏¥‡πà‡∏°", type: "stop" },
      { lat: 16.834723, lon: 100.213696, t: "12:11", p: "PSRU ‚Äî ‡∏™‡∏≠‡∏á‡πÅ‡∏Ñ‡∏ß ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏≠‡∏ô", type: "current" }
    ];

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa0c4ff);
    scene.fog = new THREE.FogExp2(0xd6e5fa, 0.005);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 800);
    // Initial position set after train is placed
    camera.position.set(5, 25, 35);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, -5);

    // --- COORDINATE MAPPING ---
    const centerLat = 17.8, centerLon = 99.6, scale = 60;
    const toXZ = (lat, lon) => [(lon - centerLon) * scale, -(lat - centerLat) * scale];

    function elev(lat) {
      const base = lat > 18.2 ? 2.5 : lat > 17.5 ? 1.2 : 0.3;
      return base + Math.sin(lat * 15) * 0.4;
    }

    // --- ROUTE & TRACK DEFINITION (Moved up for terrain processing) ---
    const routePts = waypoints.map(w => {
      const [x, z] = toXZ(w.lat, w.lon);
      return new THREE.Vector3(x, elev(w.lat) + 0.15, z);
    });
    const curve = new THREE.CatmullRomCurve3(routePts, false, 'centripetal', 0.3);

    // --- TERRAIN ---
    const terrainSize = 250; // Increased size
    const terrainSeg = 150; // Higher resolution for mountains and river valleys
    const terrainGeo = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSeg, terrainSeg);
    terrainGeo.rotateX(-Math.PI / 2);

    // Create a river path curve
    const riverPts = [
      new THREE.Vector3(-100, 0, -80),
      new THREE.Vector3(-60, 0, -20),
      new THREE.Vector3(-10, 0, 10),
      new THREE.Vector3(30, 0, 0),
      new THREE.Vector3(70, 0, 30),
      new THREE.Vector3(120, 0, 80)
    ];
    const riverCurve = new THREE.CatmullRomCurve3(riverPts, false, 'centripetal', 0.5);

    const tPos = terrainGeo.attributes.position;
    for (let i = 0; i < tPos.count; i++) {
      const x = tPos.getX(i), z = tPos.getZ(i);
      const lat = centerLat - z / scale;

      // Base elevation
      let y = elev(lat) * 0.4
        + Math.sin(x * 0.1 + z * 0.1) * 2.0 // Larger rolling hills
        + Math.sin(x * 0.5) * Math.cos(z * 0.4) * 0.5; // Details

      // Carve River Valley
      // Find closest point on river curve (approximation by sampling)
      let minDistToRiver = Infinity;
      for (let t = 0; t <= 1; t += 0.05) {
        const rp = riverCurve.getPointAt(t);
        const d = Math.sqrt((x - rp.x) ** 2 + (z - rp.z) ** 2);
        if (d < minDistToRiver) minDistToRiver = d;
      }

      // If close to river, lower terrain to create a valley and bank
      if (minDistToRiver < 10) {
        // Create a V/U shape valley
        const depth = Math.max(0, 1 - (minDistToRiver / 10)); // 1 at center, 0 at edge
        y -= (depth * 3.0); // Dig down
        // Flatten the bottom slightly for the water
        if (y < -0.5) y = -0.5;
      }

      // Add distant mountains (only if far from center/track)
      if (Math.abs(x) > 60 || Math.abs(z) > 80) {
        y += (Math.abs(x) + Math.abs(z)) * 0.05 * Math.random();
      }

      // Ensure train track path is clear (flatten terrain near the track)
      let minDistToTrack = Infinity;
      const trackPointCount = 100; // Number of points to sample along the curve
      for (let j = 0; j <= trackPointCount; j++) {
        const t = j / trackPointCount;
        const trackP = curve.getPointAt(t);
        const d = Math.sqrt((x - trackP.x) ** 2 + (z - trackP.z) ** 2);
        if (d < minDistToTrack) minDistToTrack = d;
      }
      // If within 14 units of the track, flatten
      if (minDistToTrack < 14) {
        // Soft blend to the target track elevation
        const blend = Math.max(0, 1 - (minDistToTrack / 14)); // 1 at center, 0 at edge
        const trackElev = elev(lat) * 0.4 + 0.1; // Target elevation slightly above base terrain
        y = THREE.MathUtils.lerp(y, trackElev, blend * 0.8); // Blend with 80% strength
      }

      tPos.setY(i, y);
    }
    terrainGeo.computeVertexNormals();

    const terrainMat = new THREE.MeshStandardMaterial({
      color: 0x3d7045, // Lush Morning green
      roughness: 0.9,
      metalness: 0.05,
      flatShading: true
    });
    scene.add(new THREE.Mesh(terrainGeo, terrainMat));

    // --- RIVER/WATER ---
    const waterGeo = new THREE.PlaneGeometry(terrainSize, terrainSize, 10, 10);
    waterGeo.rotateX(-Math.PI / 2);
    const waterMat = new THREE.MeshStandardMaterial({
      color: 0x4dd0e1, // Cyan/Blue water
      emissive: 0x0077aa,
      emissiveIntensity: 0.2,
      transparent: true,
      opacity: 0.8,
      roughness: 0.1,
      metalness: 0.8
    });
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.position.y = -0.1; // Water level
    scene.add(water);



    // Grid overlay - removed for natural look, kept commented out just in case
    /*
    const gridMat = new THREE.MeshStandardMaterial({
      color: 0x2b4c33,
      wireframe: true,
      transparent: true,
      opacity: 0.1
    });
    scene.add(new THREE.Mesh(terrainGeo.clone(), gridMat));
    */

    // --- TREES & FORESTS ---
    const treeGeo = new THREE.ConeGeometry(0.8, 3, 5);
    const trunkGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 5);
    const treeMat = new THREE.MeshStandardMaterial({ color: 0x2d5a3f, roughness: 0.8, flatShading: true });
    const treeMat2 = new THREE.MeshStandardMaterial({ color: 0x3d7a4f, roughness: 0.8, flatShading: true }); // Muted green variant
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.9 });

    // Instanced mesh is better for performance, but for simplicity we'll group them
    const forest = new THREE.Group();

    function getTerrainHeightAt(x, z) {
      // Very rough approximation based on the math above
      const lat = centerLat - z / scale;
      let y = elev(lat) * 0.4 + Math.sin(x * 0.1 + z * 0.1) * 2.0 + Math.sin(x * 0.5) * Math.cos(z * 0.4) * 0.5;
      // Skip river valley and distant mountains for this simplified check
      return y;
    }

    // Add random trees
    for (let i = 0; i < 400; i++) {
      const x = (Math.random() - 0.5) * 200;
      const z = (Math.random() - 0.5) * 200;

      // Calculate height (approx)
      const y = getTerrainHeightAt(x, z) + 0.5;

      // Don't place trees in the river
      if (y < 0.2) continue;

      // Much wider tree clearance area to ensure they don't block the train or tracks
      // We check distance from the tree to the entire track curve
      let nearTrack = false;
      // We haven't created the curve yet, so we have to quickly check waypoints segments
      // Or we can just build the curve first. For simplicity, we'll do segment distance check.
      for (let w = 0; w < waypoints.length - 1; w++) {
        const [x1, z1] = toXZ(waypoints[w].lat, waypoints[w].lon);
        const [x2, z2] = toXZ(waypoints[w + 1].lat, waypoints[w + 1].lon);

        // Distance from point to line segment
        const A = x - x1;
        const B = z - z1;
        const C = x2 - x1;
        const D = z2 - z1;

        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if (len_sq != 0) //in case of 0 length line
          param = dot / len_sq;

        let xx, zz;

        if (param < 0) {
          xx = x1;
          zz = z1;
        }
        else if (param > 1) {
          xx = x2;
          zz = z2;
        }
        else {
          xx = x1 + param * C;
          zz = z1 + param * D;
        }

        const dx = x - xx;
        const dz = z - zz;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < 12) { // Clearance radius around track
          nearTrack = true;
          break;
        }
      }
      if (nearTrack) continue;

      const tree = new THREE.Group();

      const leaves = new THREE.Mesh(treeGeo, Math.random() > 0.5 ? treeMat : treeMat2);
      leaves.position.y = 1.5;

      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 0.5;

      tree.add(leaves);
      tree.add(trunk);

      tree.position.set(x, y, z);

      // Random scale and rotation
      const s = 0.5 + Math.random() * 1.2;
      tree.scale.set(s, s * (0.8 + Math.random() * 0.4), s);
      tree.rotation.y = Math.random() * Math.PI * 2;
      tree.rotation.x = (Math.random() - 0.5) * 0.1; // Slight lean

      forest.add(tree);
    }
    scene.add(forest);

    // --- SOLID RAILWAY TRACK ---
    // Instead of glowing tubes, let's create a solid railway bed
    const trackMat = new THREE.MeshStandardMaterial({
      color: 0x333333,
      roughness: 0.8,
      metalness: 0.2
    });
    const trackGeo = new THREE.TubeGeometry(curve, 500, 0.4, 4, false); // Rectangularish profile
    // Flatten the top of the tube somewhat
    const pos = trackGeo.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      // Flatten geometry to make a flat track bed
      pos.setY(i, pos.getY(i) * 0.5);
    }
    trackGeo.computeVertexNormals();
    scene.add(new THREE.Mesh(trackGeo, trackMat));

    // Metallic Rails on top
    const railOffset = 0.18;
    for (let side of [-1, 1]) {
      const pts = [];
      for (let t = 0; t <= 1; t += 0.002) {
        const p = curve.getPointAt(t);
        const tan = curve.getTangentAt(t).normalize();
        const right = new THREE.Vector3().crossVectors(tan, new THREE.Vector3(0, 1, 0)).normalize();
        // Slightly raised above the track bed
        pts.push(p.clone().add(right.multiplyScalar(side * railOffset)).add(new THREE.Vector3(0, 0.1, 0)));
      }
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineBasicMaterial({ color: 0x999999 });
      scene.add(new THREE.Line(geo, mat));
    }

    // Route ground glow
    const glowTube = new THREE.MeshStandardMaterial({
      color: 0x3366cc,
      emissive: 0x3366cc,
      emissiveIntensity: 0.2,
      transparent: true,
      opacity: 0.2
    });
    scene.add(new THREE.Mesh(new THREE.TubeGeometry(curve, 300, 0.8, 8, false), glowTube));

    // --- BRIDGES / PILLARS ---
    // Add bridge pillars where the track goes over the river (y <= 0)
    const bridgeGeo = new THREE.CylinderGeometry(0.3, 0.5, 3, 8);
    const bridgeMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.9, flatShading: true });

    for (let t = 0; t <= 1; t += 0.01) {
      const p = curve.getPointAt(t);
      // Check if distance to river is very close based on our river points
      let minDistToRiver = Infinity;
      for (let rt = 0; rt <= 1; rt += 0.05) {
        const rp = riverCurve.getPointAt(rt);
        const d = Math.sqrt((p.x - rp.x) ** 2 + (p.z - rp.z) ** 2);
        if (d < minDistToRiver) minDistToRiver = d;
      }

      // If the track is over the river valley, build a bridge support
      if (minDistToRiver < 8) {
        // Create pillar going down to water level
        const pillar = new THREE.Mesh(bridgeGeo, bridgeMat);
        // Position pillar directly under track
        pillar.position.set(p.x, p.y - 1.5, p.z);
        scene.add(pillar);
      }
    }

    // --- WAYPOINT MARKERS ---
    const wpColors = { start: 0x3fb950, travel: 0x2a5a8a, stop: 0xf0883e, current: 0xf778ba };
    const wpSizes = { start: 0.35, travel: 0.1, stop: 0.25, current: 0.4 };

    waypoints.forEach((w, i) => {
      const [x, z] = toXZ(w.lat, w.lon);
      const y = elev(w.lat) + 0.15;

      if (w.type === 'start' || w.type === 'stop' || w.type === 'current') {
        // --- STATION PLATFORM ---
        // Add a simple platform at major stops
        const platformGeo = new THREE.BoxGeometry(3, 0.2, 8);
        const platformMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.8 });
        const platform = new THREE.Mesh(platformGeo, platformMat);
        // Position platform alongside the track
        platform.position.set(x + 1.8, y - 0.05, z);

        // Add a small station roof
        const roofGeo = new THREE.BoxGeometry(2.5, 0.1, 7);
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x3a5a7a, roughness: 0.5 });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.set(x + 1.8, y + 1.2, z);

        // Roof pillars
        const stPillarGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.2, 4);
        const stPillarMat = new THREE.MeshStandardMaterial({ color: 0xdddddd });
        for (let pz of [-3, 0, 3]) {
          for (let px of [-1, 1]) {
            const stPill = new THREE.Mesh(stPillarGeo, stPillarMat);
            stPill.position.set(x + 1.8 + px * 1.1, y + 0.6, z + pz);
            scene.add(stPill);
          }
        }

        scene.add(platform);
        scene.add(roof);

        // Beacon pillar (existing)
        const pillarH = w.type === 'current' ? 4 : 2.5;
        const pillarGeo = new THREE.CylinderGeometry(0.03, 0.03, pillarH, 6);
        const pillarMat = new THREE.MeshStandardMaterial({
          color: wpColors[w.type],
          emissive: wpColors[w.type],
          emissiveIntensity: 0.5,
          transparent: true,
          opacity: 0.4
        });
        const pillar = new THREE.Mesh(pillarGeo, pillarMat);
        pillar.position.set(x, y + pillarH / 2, z);
        scene.add(pillar);

        // Top sphere
        const sGeo = new THREE.SphereGeometry(wpSizes[w.type], 16, 16);
        const sMat = new THREE.MeshStandardMaterial({
          color: wpColors[w.type],
          emissive: wpColors[w.type],
          emissiveIntensity: 0.8
        });
        const sphere = new THREE.Mesh(sGeo, sMat);
        sphere.position.set(x, y + pillarH, z);
        scene.add(sphere);

        // Ground ring
        const ringGeo = new THREE.RingGeometry(0.3, 0.5, 24);
        ringGeo.rotateX(-Math.PI / 2);
        const ringMat = new THREE.MeshStandardMaterial({
          color: wpColors[w.type],
          emissive: wpColors[w.type],
          emissiveIntensity: 0.5,
          transparent: true,
          opacity: 0.3,
          side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.set(x, y + 0.05, z);
        scene.add(ring);
      }
    });

    // --- BUILD TRAIN ---
    function buildTrain() {
      const train = new THREE.Group();

      // Locomotive body
      const bodyGeo = new THREE.BoxGeometry(0.7, 0.5, 1.8);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0xcc3333,
        emissive: 0x331111,
        emissiveIntensity: 0.3,
        roughness: 0.4,
        metalness: 0.6
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.4;
      train.add(body);

      // Roof
      const roofGeo = new THREE.BoxGeometry(0.6, 0.1, 1.6);
      const roofMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.3 });
      const roof = new THREE.Mesh(roofGeo, roofMat);
      roof.position.y = 0.7;
      train.add(roof);

      // Nose (front taper)
      const noseGeo = new THREE.CylinderGeometry(0.25, 0.35, 0.5, 6);
      noseGeo.rotateX(Math.PI / 2);
      const nose = new THREE.Mesh(noseGeo, bodyMat);
      nose.position.set(0, 0.4, 1.1);
      train.add(nose);

      // Chimney
      const chimGeo = new THREE.CylinderGeometry(0.06, 0.08, 0.35, 8);
      const chimMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9 });
      const chim = new THREE.Mesh(chimGeo, chimMat);
      chim.position.set(0, 0.9, 0.5);
      train.add(chim);

      // Headlight
      const hlGeo = new THREE.SphereGeometry(0.08, 8, 8);
      const hlMat = new THREE.MeshStandardMaterial({
        color: 0xffee88,
        emissive: 0xffee88,
        emissiveIntensity: 2
      });
      const hl = new THREE.Mesh(hlGeo, hlMat);
      hl.position.set(0, 0.45, 1.35);
      train.add(hl);

      // Headlight beam
      const beamLight = new THREE.SpotLight(0xffdd66, 8, 15, 0.4, 0.5, 1);
      beamLight.position.set(0, 0.45, 1.35);
      beamLight.target.position.set(0, 0, 5);
      train.add(beamLight);
      train.add(beamLight.target);

      // Wheels (4 pairs)
      const wheelGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 12);
      wheelGeo.rotateZ(Math.PI / 2);
      const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.2 });
      for (let z of [-0.5, 0, 0.5, 0.9]) {
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.position.set(0, 0.12, z);
        train.add(wheel);
      }

      // Windows (both sides)
      const winMat = new THREE.MeshStandardMaterial({
        color: 0xffcc44,
        emissive: 0xffaa22,
        emissiveIntensity: 1.5,
        transparent: true,
        opacity: 0.9
      });
      for (let side of [-1, 1]) {
        for (let z of [-0.3, 0.2]) {
          const winGeo = new THREE.PlaneGeometry(0.001, 0.2, 0.3);
          const win = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.18, 0.25), winMat);
          win.position.set(side * 0.36, 0.45, z);
          train.add(win);
        }
      }

      // Carriage 1
      const c1 = new THREE.Group();
      const c1Body = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.45, 1.5),
        new THREE.MeshStandardMaterial({ color: 0x1a4a8a, emissive: 0x0a1a3a, emissiveIntensity: 0.2, roughness: 0.4, metalness: 0.5 })
      );
      c1Body.position.y = 0.38;
      c1.add(c1Body);
      const c1Roof = new THREE.Mesh(roofGeo.clone(), roofMat.clone());
      c1Roof.position.y = 0.65;
      c1.add(c1Roof);
      // Carriage windows
      for (let side of [-1, 1]) {
        for (let z of [-0.4, -0.1, 0.2, 0.5]) {
          const win = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.15, 0.2), winMat);
          win.position.set(side * 0.31, 0.42, z);
          c1.add(win);
        }
      }
      for (let z of [-0.3, 0.3]) {
        const wh = new THREE.Mesh(wheelGeo.clone(), wheelMat.clone());
        wh.position.set(0, 0.12, z);
        c1.add(wh);
      }

      // More Carriages!
      const c2 = c1.clone();
      const c3 = c1.clone();
      const c4 = c1.clone();

      return { locomotive: train, carriage1: c1, carriage2: c2, carriage3: c3, carriage4: c4 };
    }

    const { locomotive, carriage1, carriage2, carriage3, carriage4 } = buildTrain();
    scene.add(locomotive);
    scene.add(carriage1);
    scene.add(carriage2);
    scene.add(carriage3);
    scene.add(carriage4);

    // --- SMOKE PARTICLES ---
    const smokeCount = 200;
    const smokeGeo = new THREE.BufferGeometry();
    const smokePositions = new Float32Array(smokeCount * 3);
    const smokeSizes = new Float32Array(smokeCount);
    const smokeAlphas = new Float32Array(smokeCount);
    const smokeVelocities = [];

    for (let i = 0; i < smokeCount; i++) {
      smokePositions[i * 3] = 0;
      smokePositions[i * 3 + 1] = -100;
      smokePositions[i * 3 + 2] = 0;
      smokeSizes[i] = 0;
      smokeAlphas[i] = 0;
      smokeVelocities.push({ vx: 0, vy: 0, vz: 0, life: 0, maxLife: 0 });
    }

    smokeGeo.setAttribute('position', new THREE.BufferAttribute(smokePositions, 3));
    smokeGeo.setAttribute('size', new THREE.BufferAttribute(smokeSizes, 1));

    const smokeMat = new THREE.PointsMaterial({
      color: 0x888899,
      size: 0.5,
      transparent: true,
      opacity: 0.4,
      sizeAttenuation: true,
      depthWrite: false
    });
    const smoke = new THREE.Points(smokeGeo, smokeMat);
    scene.add(smoke);

    let smokeIdx = 0;
    function emitSmoke(pos) {
      const i = smokeIdx % smokeCount;
      smokePositions[i * 3] = pos.x + (Math.random() - 0.5) * 0.1;
      smokePositions[i * 3 + 1] = pos.y + 0.9;
      smokePositions[i * 3 + 2] = pos.z + (Math.random() - 0.5) * 0.1;
      smokeSizes[i] = 0.15;
      smokeVelocities[i] = {
        vx: (Math.random() - 0.5) * 0.3,
        vy: 0.5 + Math.random() * 0.5,
        vz: (Math.random() - 0.5) * 0.3,
        life: 0,
        maxLife: 1.5 + Math.random() * 1.5
      };
      smokeIdx++;
    }

    function updateSmoke(dt) {
      for (let i = 0; i < smokeCount; i++) {
        const v = smokeVelocities[i];
        if (v.life < v.maxLife) {
          v.life += dt;
          const t = v.life / v.maxLife;
          smokePositions[i * 3] += v.vx * dt;
          smokePositions[i * 3 + 1] += v.vy * dt;
          smokePositions[i * 3 + 2] += v.vz * dt;
          smokeSizes[i] = 0.15 + t * 0.8;
          v.vy *= 0.98;
        } else {
          smokePositions[i * 3 + 1] = -100;
          smokeSizes[i] = 0;
        }
      }
      smokeGeo.attributes.position.needsUpdate = true;
      smokeGeo.attributes.size.needsUpdate = true;
    }

    // --- SPARK PARTICLES ---
    const sparkCount = 100;
    const sparkGeo = new THREE.BufferGeometry();
    const sparkPositions = new Float32Array(sparkCount * 3);
    const sparkVels = [];
    for (let i = 0; i < sparkCount; i++) {
      sparkPositions[i * 3 + 1] = -100;
      sparkVels.push({ vx: 0, vy: 0, vz: 0, life: 0, maxLife: 0 });
    }
    sparkGeo.setAttribute('position', new THREE.BufferAttribute(sparkPositions, 3));
    const sparkMat = new THREE.PointsMaterial({
      color: 0xffaa44,
      size: 0.08,
      transparent: true,
      opacity: 0.8,
      sizeAttenuation: true,
      depthWrite: false
    });
    scene.add(new THREE.Points(sparkGeo, sparkMat));

    let sparkIdx = 0;
    function emitSparks(pos) {
      for (let j = 0; j < 3; j++) {
        const i = sparkIdx % sparkCount;
        sparkPositions[i * 3] = pos.x + (Math.random() - 0.5) * 0.5;
        sparkPositions[i * 3 + 1] = pos.y;
        sparkPositions[i * 3 + 2] = pos.z + (Math.random() - 0.5) * 0.5;
        sparkVels[i] = {
          vx: (Math.random() - 0.5) * 2,
          vy: Math.random() * 2,
          vz: (Math.random() - 0.5) * 2,
          life: 0,
          maxLife: 0.3 + Math.random() * 0.4
        };
        sparkIdx++;
      }
    }

    function updateSparks(dt) {
      for (let i = 0; i < sparkCount; i++) {
        const v = sparkVels[i];
        if (v.life < v.maxLife) {
          v.life += dt;
          sparkPositions[i * 3] += v.vx * dt;
          sparkPositions[i * 3 + 1] += v.vy * dt - 4 * dt * dt;
          sparkPositions[i * 3 + 2] += v.vz * dt;
          v.vy -= 6 * dt;
        } else {
          sparkPositions[i * 3 + 1] = -100;
        }
      }
      sparkGeo.attributes.position.needsUpdate = true;
    }

    // --- LIGHTS ---
    scene.add(new THREE.AmbientLight(0xd9e5ff, 1.8));

    const sunLight = new THREE.DirectionalLight(0xfff5b6, 2.5);
    sunLight.position.set(-30, 60, -20);
    scene.add(sunLight);

    const trainGlow = new THREE.PointLight(0xffeb3b, 1.5, 12);
    scene.add(trainGlow);

    const destGlow = new THREE.PointLight(0xf778ba, 2.5, 20);
    const [dx, dz] = toXZ(waypoints[waypoints.length - 1].lat, waypoints[waypoints.length - 1].lon);
    destGlow.position.set(dx, 5, dz);
    scene.add(destGlow);

    // --- STARS ---
    // Hidden in morning mode
    /*
    const starsGeo2 = new THREE.BufferGeometry();
    const sv = [];
    for (let i = 0; i < 4000; i++) {
      const r = 150 + Math.random() * 100;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI * 0.4;
      sv.push(
        r * Math.sin(phi) * Math.cos(theta),
        30 + r * Math.cos(phi),
        r * Math.sin(phi) * Math.sin(theta)
      );
    }
    starsGeo2.setAttribute('position', new THREE.Float32BufferAttribute(sv, 3));
    const starsMat2 = new THREE.PointsMaterial({
      color: 0xccccff,
      size: 0.15,
      transparent: true,
      opacity: 0.7,
      sizeAttenuation: true
    });
    scene.add(new THREE.Points(starsGeo2, starsMat2));
    */

    // --- CLOUDS / MORNING MIST ---
    const cloudGeo = new THREE.IcosahedronGeometry(4, 1);
    const cloudMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8,
      roughness: 1.0,
      flatShading: true
    });
    const clouds = new THREE.Group();
    for (let i = 0; i < 20; i++) {
      const cloud = new THREE.Mesh(cloudGeo, cloudMat);
      cloud.position.set(
        (Math.random() - 0.5) * 200,
        15 + Math.random() * 15,
        (Math.random() - 0.5) * 200
      );
      cloud.scale.set(1 + Math.random() * 2, 0.5, 1 + Math.random() * 2);
      clouds.add(cloud);
    }
    scene.add(clouds);

    // --- ANIMATE WATERFALL ---
    const waterfallCliffPos = new THREE.Vector3(50, 0, 0); // Base position of the cliff
    const waterfallCliffGeo = new THREE.CylinderGeometry(5, 8, 15, 8); // RadiusTop, RadiusBottom, Height, RadialSegments
    const waterfallCliffMat = new THREE.MeshStandardMaterial({ color: 0x6b4e3e, roughness: 0.8 });
    const waterfallCliff = new THREE.Mesh(waterfallCliffGeo, waterfallCliffMat);
    waterfallCliff.position.set(waterfallCliffPos.x, waterfallCliffPos.y + 7.5, waterfallCliffPos.z); // Center the cylinder vertically
    scene.add(waterfallCliff);

    const dropCount = 150;
    const dropGeo = new THREE.BufferGeometry();
    const dropPositions = new Float32Array(dropCount * 3);
    const dropVels = [];

    for (let i = 0; i < dropCount; i++) {
      dropPositions[i * 3 + 1] = -100;
      dropVels.push({ vy: 0 });
    }
    dropGeo.setAttribute('position', new THREE.BufferAttribute(dropPositions, 3));
    const dropMat = new THREE.PointsMaterial({
      color: 0xe0f7fa,
      size: 0.4,
      transparent: true,
      opacity: 0.7,
      sizeAttenuation: true,
      depthWrite: false
    });
    const waterfallParticles = new THREE.Points(dropGeo, dropMat);
    scene.add(waterfallParticles);

    let dropIdx = 0;
    function updateWaterfall(dt) {
      // Spawn new drops at the top of the cliff
      for (let j = 0; j < 5; j++) {
        const i = dropIdx % dropCount;
        dropPositions[i * 3] = waterfallCliffPos.x + (Math.random() - 0.5) * 6 + 4; // Shift to one side of the cylinder
        dropPositions[i * 3 + 1] = waterfallCliffPos.y + 12; // Top of cliff
        dropPositions[i * 3 + 2] = waterfallCliffPos.z + (Math.random() - 0.5) * 4;
        dropVels[i].vy = -(Math.random() * 2 + 2); // Initial downward velocity
        dropIdx++;
      }

      // Move existing drops
      for (let i = 0; i < dropCount; i++) {
        if (dropPositions[i * 3 + 1] > -1) { // Above water level
          dropPositions[i * 3 + 1] += dropVels[i].vy * dt; // Apply gravity basically
          dropVels[i].vy -= 15 * dt; // Gravity acceleration
        } else {
          dropPositions[i * 3 + 1] = -100; // Reset hidden
        }
      }
      dropGeo.attributes.position.needsUpdate = true;
    }

    // --- STATE ---
    let playing = true;
    let followCam = true;
    let playT = 0;
    let playSpeed = 0.04;
    const clock = new THREE.Clock();

    function positionTrain(group, t, offset = 0) {
      const ct = Math.max(0, Math.min(1, t - offset));
      if (ct <= 0) { group.visible = false; return; }
      group.visible = true;
      const p = curve.getPointAt(ct);
      const lookT = Math.min(1, ct + 0.005);
      const ahead = curve.getPointAt(lookT);
      group.position.copy(p);
      group.lookAt(ahead);
    }

    function nearestWP(t) {
      const p = curve.getPointAt(t);
      let best = 0, bd = Infinity;
      waypoints.forEach((w, i) => {
        const [x, z] = toXZ(w.lat, w.lon);
        const d = Math.sqrt((p.x - x) ** 2 + (p.z - z) ** 2);
        if (d < bd) { bd = d; best = i; }
      });
      return best;
    }

    // --- CONTROLS ---
    window.togglePlay = () => {
      playing = !playing;
      if (playing && playT >= 0.99) playT = 0;
      document.getElementById('playBtn').textContent = playing ? '‚è∏ Pause' : '‚ñ∂ Depart';
      document.getElementById('playBtn').classList.toggle('active', playing);
    };

    window.toggleCamera = () => {
      followCam = !followCam;
      document.getElementById('camBtn').textContent = followCam ? 'üé• On Train' : 'üé• Orbit';
      document.getElementById('camBtn').classList.toggle('active', followCam);
      if (!followCam) {
        controls.enabled = true;
        camera.position.set(5, 25, 35);
        controls.target.set(0, 0, -5);
      }
    };

    window.resetView = () => {
      playT = 0;
      playing = false;
      followCam = false;
      document.getElementById('playBtn').textContent = '‚ñ∂ Depart';
      document.getElementById('playBtn').classList.remove('active');
      document.getElementById('camBtn').classList.remove('active');
      controls.enabled = true;
      camera.position.set(5, 25, 35);
      controls.target.set(0, 0, -5);
    };

    // Start at beginning
    positionTrain(locomotive, 0);
    positionTrain(carriage1, 0, 0.015);
    positionTrain(carriage2, 0, 0.03);
    positionTrain(carriage3, 0, 0.045);
    positionTrain(carriage4, 0, 0.06);

    // --- ANIMATE ---
    let smokeTimer = 0;
    let sparkTimer = 0;

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      if (playing) {
        playT += dt * playSpeed;
        if (playT >= 1) { playT = 1; playing = false; document.getElementById('playBtn').textContent = '‚ñ∂ Replay'; }
      }

      // Position train
      positionTrain(locomotive, playT);
      positionTrain(carriage1, playT, 0.015);
      positionTrain(carriage2, playT, 0.03);
      positionTrain(carriage3, playT, 0.045);
      positionTrain(carriage4, playT, 0.06);

      // Train light follows
      if (locomotive.visible) {
        trainGlow.position.copy(locomotive.position);
        trainGlow.position.y += 1.5;
      }

      // Smoke
      if (playing && locomotive.visible) {
        smokeTimer += dt;
        if (smokeTimer > 0.03) {
          emitSmoke(locomotive.position);
          smokeTimer = 0;
        }
        sparkTimer += dt;
        if (sparkTimer > 0.08) {
          emitSparks(locomotive.position);
          sparkTimer = 0;
        }
      }
      updateSmoke(dt);
      updateSparks(dt);

      // HUD
      if (locomotive.visible) {
        const wpIdx = nearestWP(playT);
        document.getElementById('locName').textContent = waypoints[wpIdx].p;
        document.getElementById('locTime').textContent = waypoints[wpIdx].t;
      }
      document.getElementById('progressBar').style.width = (playT * 100) + '%';

      // Follow camera ‚Äî behind and above the train, cinematic chase view
      if (followCam && locomotive.visible) {
        controls.enabled = false;
        const lp = locomotive.position;
        const tan = curve.getTangentAt(Math.min(playT, 0.999)).normalize();
        const right = new THREE.Vector3().crossVectors(tan, new THREE.Vector3(0, 1, 0)).normalize();
        const lookAhead = lp.clone().add(tan.clone().multiplyScalar(10));
        lookAhead.y = lp.y + 0.8;
        const camPos = lp.clone()
          .add(new THREE.Vector3(0, 4.5, 0))
          .sub(tan.clone().multiplyScalar(6))
          .add(right.clone().multiplyScalar(1.5));
        camera.position.lerp(camPos, 0.04);
        camera.lookAt(lookAhead);
      } else {
        controls.enabled = true;
        controls.update();
      }

      // Pulse destination
      destGlow.intensity = 3 + Math.sin(clock.elapsedTime * 2) * 1.5;

      // Animate clouds drifting
      clouds.position.x += dt * 0.5;
      if (clouds.position.x > 100) clouds.position.x = -100;

      // Animate Waterfall
      updateWaterfall(dt);

      renderer.render(scene, camera);
    }
    animate();

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>

</html>